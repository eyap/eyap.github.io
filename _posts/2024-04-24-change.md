### 파일 변환
```javascript
scwin.convert = undefined;
scwin.name = undefined;
scwin.loaded = false;

scwin.onpageload = function() {
	// 변환 대상 함수 데이터
	const functionJson = [
		{asis: 'comLib.executeSubmission', tobe: 'knp.sbm.execute'},
		{asis: 'comLib.alert', tobe: 'knp.win.alert'},
		{asis: '$w.log', tobe: '$p.log', match:'\\$w\\.log'}
	];
	// 수정항목 추가 설명
	const resultEtcJSON = [
		{key: "script", title: "script 태그 속성(lazy)", count: 0, lineNum: ""},
		{key: "w2:wframe", title: "main_title.xml id부여,src체크", count: 0, lineNum: ""}
	]
	dlt_tobe.setJSON(functionJson);
	dlt_resultFuncName.setJSON(resultEtcJSON);
	grp_desc.hide();
	scwin.drawDesc();
	//event
	grp_contents.render.addEventListener('drop', scwin.ondrop);
}

scwin.btn_send_onclick = function(e) {
	// 소스파일을 ajax로 가져온다.
	scwin.send(scwin.getUrl());
}

// 변환된 파일 다운로드
scwin.btn_down_onclick = function(e) {
	scwin.download(scwin.name, scwin.convert);
}

scwin.btn_toggle_onclick = function(e) {
	if(grp_desc.getStyle("display") != "none")
		grp_desc_hide();
	else
		grp_desc.show();
}

// 변환함수 목록 출력
scwin.drawDesc = function() {
	const arr = dlt_tobe.getAllJSON();
	arr.forEach((v,i) => {
		const idx = gen_desc.insertChild();
		const tbx_row = gen_desc.getChild(idx, "tbx_row");
		const tbx_fncName1 = gen_desc.getChild(idx, "tbx_fncName1");
		const tbx_fncName2 = gen_desc.getChild(idx, "tbx_fncName2");
		const tbx_fncDesc = gen_desc.getChild(idx, "tbx_fncDesc");
		
		tbx_row.setValue(i + 1);
		tbx_fncName1.setValue(v.asis);
		tbx_fncName2.setValue(v.tobe);
		tbx_fncDesc.setValue(v.update);
	});
}

scwin.getUrl = function() {
	const v = sbx_url.getValue().trim().replace(/\.websquare$/, '.xml');
	if(v == "") return "";
	const name = v.split("/").slice(-1)[0];
	if(!name.endsWith(".xml")) return "";
	const fixArr = ['w2x', 'ui', name.substr(0,4).toLowerCase()];
	let url = v;
	
	if(v.charAt(0) != '/') {
		url = "/" + fixArr.join("/") + "/" + name;
	}
	scwin.name = name;
	return url;
}

scwin.getNameFromURL = function(url) {
	if(url == null) return "";
	const name = url.trim().replace(/\.websquare$/, ".xml").split("/").slice(-1)[0];
	return !name.endsWith(".xml") ? "undefined.xml" : name;
}

scwin.init = function() {
	scwin.convert = undefined;
	scwin.name =undefined;
	tbx_prev.setValue("");
	gen_fnc.removeAll();	
}

// 변환
scwin.change = async function(name, str) {
	const arr = dlt_tobe.getAllJSON();
	const getHandler = (a, nums, funcs) => {
		return (num) => {
			return (m, g1, g2) => {
				if(nums.indexOf(num) < 0) nums.push(num);
				if(funcs[g1] == null) {
					funcs[g1] = [];
				}
				if(funcs[g1].indexOf(num) < 0) funcs[g1].push(num);
				return a + g2;
			}
		}
	} // end of gethandler

	const lines1 = str.split(/\r?\n/);
	const lines2 = str.replace(/\</g, '&lt;').split(/\r?\n/);
	const nums = [];
	const funcs = {};
	const existsCheckJSON = [
		{asis: "scwin.onpageload", match: "scwin\\.onpageload\\s*=\\s*function", check: false}
	];
	// 라인별
	for(let i in lines1) {
		i = parseInt(i);
		const v = lines1[i];
		//라인 주석처리
		const remain = ["",""];
		lindes1[i] = lines1[i].replace(/(\/\/.*$)/, (m,g)=>{remain[0] = g; return "";});
		lindes1[i] = lines1[i].replace(/(\/\/.*$)/, (m,g)=>{remain[1] = g; return "";});
		// 함수
		{
			arr.forEach(x => {
				const regstr = `(${x.match||x.asis.replace('.','\\.')})(\\s*\\()`;
				const regasis = new RegExp(`${regstr}`, "g");
				const regdp = new RegExp(`${regstr}`, "g");
				const handlerTobe = gethandler(x.tobe, nums, funcs);
				const handlerDp = (m, g1, g2) => {
					return '<font color="red">' + x.tobe + '</font>' + g2;					
				}
				replcaeLIne(i, [regasis, hadnlderTobe(i+1)], [regdp, handlerDp]);
			});
		}
	} // 함수
	
	//태그(하나의 태그속성 체크, 삭제할 태그)
	{
		const addTag = [
			{asis: 'script', tobe:"lazy='false'", handler:'scwin.chageTag'},
			{asis: 'body', tobe:"ev:onpageload='scwin.onpageload'", hadnler:'scwin.chageTag'},
			{asis: 'xml-stylesheet', tobe:"", hadnler:'scwin.chageTag', match:"\\?xml\\-stylesheet"},
			{asis: 'w2:require', tobe:"", handler:'scwin.chageTag', match:""};			
		]
		const getTagHandler = (a, nums, funcs, handler) => {
			return (numb) => {
				return (m, g0, g1, g2) => {
					if(typeof handler == "function") return hadnler(m, g0, g1, g2);
					return g0 + a + g2;
				}
			}
		};
		addTag.forEach((x) => {
			const regasis = new RegExp(`(\\<)(${x.match||x.asis})([^\\<\\>]*\\>)`, g);
			const regdp = new RegExp(`(\\&lt;)(${x.match || x.asis})([^\\>]*\\>)`, "g");
			const handlerTobeCallback = (g1, flag) => {
				const num = i + 1;
				if(flag === true) {
					if(nums.indexOf(num) < 0) nums.push(num);
					if(funcs[g1] == null) {
						funcs[g1] = [];
					}
					if(funcs[g1].indexOf(num) < 0) funcs[g1].push(num);
				}
			};
			const handlerTobe = getTagHandler(x.tobe, nums, funcs, scwin.gethandler(x.handler, x.asis, x, 'replace', handlerTobeCallback));
			const handlerDp = scwin.gethandler(x.handler, x.asis, x, 'display', null);
			replaceLine(i, [regasis, handlerTobe(i + 1)], [regdp, handlerDp]);
		});
	}
	// xml 웹스퀘어 속성체크
	{
		const addXml = [
			{asis: "w2:wframe", tobe: "", hadnler: "scwin.chageXml", match: 'src\\s*=\\s*"[\\/\\w\\d\\_]*\\/main_title.xml"', key:"main_title.xml"}
		];
		const getTaghandler = (a, handler) => {
			return (...args) => {
				if(typeof handler == "function") return handler(...args);
				return args.lenght > 0 ? args[0] : "";
			}  
		}
		const gethandlerTobeCallback = (rowNum) => {
			return (g1, flag) => {
				const num = rowNum + 1;
				if(flag === true) {
					if(nums.indexOf(num) < 0) nums.push(num);
					if(funcs[g1] == null) {
						funcs[g1] = [];
					}
					if(funcs[g1].indexOf(num) < 0 ) funcs[g1].push(num);
				}
				
			}
		} // end of getHandlerTobeCallback 
	}// end of block

} // end of scwin.change
```